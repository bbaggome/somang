#.NET 8, Blazor MAUI, Supabase를 활용한 통합 서비스 플랫폼 구축 기술 청사진

---

## 제 1부: 통합 아키텍처 프레임워크

본 보고서의 첫 번째 파트는 프로젝트의 상위 수준 전략적 비전을 수립합니다. 핵심 아키텍처 패턴과 그 근거를 정의하여, 이어지는 상세 구현 섹션의 견고한 기반을 제공합니다.

### 1.1. 하이브리드-퍼스트 아키텍처 모델

#### 핵심 원칙: 코드 재사용 극대화 및 플랫폼 최적화 경험 제공

본 프로젝트는 네이티브 클라이언트(iOS, Android, Windows, macOS의 최종 사용자 대상)를 위한 **.NET MAUI Blazor Hybrid 앱**과 웹 기반 포털(사업주 및 최고 관리자 대상)을 위한 **Blazor Web App**을 활용하는 통합 아키텍처를 채택합니다. 이 접근 방식은 코드 재사용을 극대화하면서 각 플랫폼에 적합한 경험을 제공하는 것을 목표로 합니다.1

#### Blazor Hybrid 분석: 성능과 개발 편의성의 결합

Blazor Hybrid 모델은 단순한 절충안이 아닌 전략적 이점을 제공합니다. Razor 컴포넌트는 WebAssembly를 통해 브라우저에서 실행되는 것이 아니라, `BlazorWebView` 컨트롤 내에서 디바이스 상에 네이티브로 실행됩니다.2 이는.NET 플랫폼을 통해 네이티브 디바이스 기능에 완전하게 접근할 수 있음을 의미하며 1, 고성능과 깊이 있는 통합을 보장합니다. 결과적으로 이 아키텍처는 웹 기술(HTML/CSS)의 개발 단순성과 네이티브 성능의 강력함을 결합합니다.1 개발 비용을 최대 60%까지 절감하고, 플랫폼별 버그를 45% 줄이며, 시장 출시 시간을 35% 단축시키는 등의 정량적 이점을 기대할 수 있습니다.1

#### 아키텍처 다이어그램

아래 다이어그램은 본 프로젝트의 핵심 구성 요소를 시각적으로 나타냅니다.

- 최종 사용자 네이티브 앱 (.NET MAUI Blazor Hybrid)
    
- 사업주 및 관리자 웹 포털 (Blazor Web App)
    
- UI용 공유 Razor 클래스 라이브러리 (RCL)
    
- 공유 서비스/모델 클래스 라이브러리
    
- Supabase 백엔드 (인증, 데이터베이스, 스토리지, 함수)
    
- 외부 서비스 (예: 푸시 알림 게이트웨이)
    

#### ".NET 8의 핵심 패턴: 공유 UI"

Microsoft는.NET MAUI Blazor Hybrid 앱과 Blazor Web App 간의 UI 공유 아키텍처를 명시적으로 지원하고 있으며, 이를 위한 워크플로우를 간소화했습니다. 이는 전용 `.NET MAUI Blazor Hybrid and Web App` 솔루션 템플릿(`maui-blazor-web`)의 존재와 상세한 공식 설정 문서에서 명확히 드러납니다.5

이러한 접근 방식은 단순히 가능한 기술 조합이 아니라, 플랫폼 공급 업체가 의도하고 완전히 지원하는 워크플로우임을 시사합니다..NET CLI에 `dotnet new maui-blazor-web`이라는 특정 템플릿이 포함된 것은 이 패턴이 임시방편이 아님을 증명하는 강력한 증거입니다.5 더 나아가, Microsoft가 제공하는 상세한 단계별 마이그레이션 가이드는 5 개발팀에게 명확한 경로를 제시하며 프로젝트의 리스크를 줄여줍니다. 이러한 공식적인 지원은 기술 스택의 장기적인 생존 가능성과 커뮤니티 및 벤더 지원에 대한 접근성을 보장하므로, 본 프로젝트의 핵심 목표 달성을 위한 가장 효율적이고 안정적인 아키텍처 선택이라 할 수 있습니다. 따라서 프로젝트 초기부터 이 템플릿을 사용하여 시작할 것을 강력히 권장합니다.

### 1.2. Supabase 중심의 백엔드: BaaS-First 전략

#### 핵심 원칙: 백엔드 복잡성의 근본적 단순화

본 프로젝트는 Supabase를 단순한 데이터베이스가 아닌 포괄적인 백엔드로 취급하는 "Backend-as-a-Service"(BaaS) 전략을 채택합니다. 이 접근 방식은 대부분의 작업에서 전통적인 맞춤형.NET Web API 미들 티어의 필요성을 제거함으로써 아키텍처를 근본적으로 단순화합니다.6

#### 활용할 Supabase 서비스

- **데이터베이스 (PostgreSQL):** 핵심 관계형 데이터 저장소.8
    
- **자동 생성 API (PostgREST):** 모든 데이터베이스 테이블 및 뷰에 대해 즉각적이고 안전한 RESTful 엔드포인트를 제공하며, 이는 데이터 상호작용의 주요 수단이 될 것입니다.6
    
- **인증 (Auth):** 데이터베이스와 원활하게 통합되는 완전한 JWT 기반 사용자 관리 시스템.8
    
- **행 수준 보안 (Row Level Security, RLS):** 데이터베이스 수준에서 데이터 접근 규칙을 강제하는 보안 모델의 초석.10
    
- **스토리지 (Storage):** 프로필 사진이나 사업 문서와 같은 사용자 생성 파일 관리.11
    
- **실시간 (Realtime):** 클라이언트에 실시간 업데이트(예: 알림) 푸시.11
    
- **엣지 함수 (Edge Functions):** 외부 통합이나 TypeScript/JavaScript가 필요한 서버리스 비즈니스 로직 처리.6
    

#### "애플리케이션 계층에서 데이터 계층으로의 로직 이동"

Supabase 중심 모델을 채택하는 것은 근본적인 아키텍처의 전환을 의미합니다. 전통적으로 비즈니스 로직, 권한 부여, 데이터 가공 등은 애플리케이션 계층(예:.NET API)에서 처리되었습니다. 그러나 Supabase를 사용하면 이러한 로직의 상당 부분이 Postgres 함수와, 가장 중요하게는, 행 수준 보안(RLS)을 통해 데이터 계층 자체로 이동합니다.

사용자의 "Supabase 활용 극대화" 요구는 Supabase의 핵심 가치 제안인 데이터베이스 스키마로부터 강력한 API를 자동 생성하는 기능과 직결됩니다.6 이 API는 별도의 백엔드 코드에 의해 보호되는 것이 아니라, SQL로 정의된 RLS 정책에 의해 보호됩니다.10 이는 C# 코드에서

`if (user.role == 'admin')`과 같은 조건문을 작성하는 대신, C# 클라이언트가 일반적인 쿼리를 보내면 데이터베이스 자체가 사용자의 JWT를 기반으로 결과를 필터링한다는 것을 의미합니다. 이 방식은 클라이언트 측 코드를 단순화하고, 보안 버그의 발생 가능성을 줄이며, 데이터 접근 방식에 관계없이 보안 정책이 보편적으로 적용되도록 보장합니다. 따라서 개발팀은 이 패러다임 전환을 완전히 수용해야 합니다. 별도의 포괄적인.NET Web API를 구축하는 것은 Supabase 선택의 주요 이점을 무효화하는 안티패턴이 될 것임을 본 보고서는 강조합니다.

### 1.3. 코드 재사용성 극대화를 위한 솔루션 구조

#### 핵심 원칙: 유지보수성을 위한 체계적인 구성

잘 정리된 솔루션 구조는 유지보수성의 핵심입니다. `maui-blazor-web` 템플릿을 기반으로 5, 다음과 같은 다중 프로젝트 솔루션 구조를 수립합니다.

#### 권장 프로젝트 구조

- `YourApp.sln` (솔루션 파일)
    
- `YourApp.Maui/` -.NET MAUI Blazor Hybrid 프로젝트. 플랫폼별 구성, 네이티브 진입점, `BlazorWebView`를 포함합니다.
    
- `YourApp.Web/` - 관리자/사업주 포털을 위한 Blazor Web App 프로젝트.
    
- `YourApp.Shared.UI/` - Razor 클래스 라이브러리 (RCL). MAUI 및 웹 프로젝트 모두에서 사용되는 모든 Razor 컴포넌트, 레이아웃, 정적 자산(CSS/JS)을 포함하는 가장 중요한 공유 프로젝트입니다.5
    
- `YourApp.Shared.Models/` - 표준.NET 클래스 라이브러리. Supabase 테이블에 매핑되는 모든 DTO(Data Transfer Objects) 및 데이터 모델(예: `User`, `Product`, `Order`)을 포함합니다.
    
- `YourApp.Shared.Services/` - 표준.NET 클래스 라이_S_S러리. `supabase-csharp` 클라이언트 구현, 상태 관리 로직(Fluxor), 네이티브 서비스용 인터페이스 등 공유 서비스 로직을 포함합니다.
    

---

## 제 2부: 프론트엔드 구현: 다중 역할, 크로스 플랫폼 경험 제작

이 파트에서는 상위 수준의 아키텍처에서 벗어나, 세 가지 다른 역할에 대한 사용자 인터페이스를 두 가지 다른 클라이언트 기술로 구축하는 실질적인 측면을 다룹니다.

### 2.1. 네이티브 클라이언트:.NET MAUI Blazor Hybrid

#### `BlazorWebView` 컨트롤: 하이브리드 앱의 심장

`BlazorWebView` 컨트롤은 하이브리드 앱의 핵심입니다. 이 컨트롤은 Blazor 런타임을 호스팅하고 공유 RCL의 Razor 컴포넌트를 렌더링합니다. 이는 전통적인 웹 브라우저가 아니라, 웹 콘텐츠를 로컬에서 렌더링하는 네이티브 UI 컴포넌트입니다.2

#### 네이티브 API 상호작용

`BlazorWebView` 내에서 실행되는 공유 C# 코드는.NET MAUI의 API에 완전히 접근할 수 있습니다. 이를 통해 GPS, 카메라, 로컬 알림, 파일 시스템과 같은 네이티브 디바이스 기능에 원활하게 접근할 수 있습니다.1 크로스 플랫폼 추상화가 불가능한 경우, 플랫폼별 코드를 위해 조건부 컴파일(

`#if ANDROID`, `#if IOS`)을 사용하는 방법을 상세히 다룰 것입니다.15

#### 플랫폼별 UI 고려사항

UI가 공유되더라도 플랫폼 간 렌더링에는 미묘한 차이가 있을 수 있습니다. 본 보고서는 플랫폼별 CSS나 컴포넌트 내 조건부 로직을 사용하여 이러한 차이를 해결해야 할 필요성을 강조할 것입니다.2 예를 들어, iOS 디바이스의 "안전 영역(safe area)" 처리가 이에 해당합니다.

### 2.2. 웹 포털: Blazor Web App

#### 올바른 렌더 모드 선택

.NET 8은 여러 렌더 모드를 갖춘 통합 Blazor를 도입했습니다. 데이터 집약적이고 강력한 보안이 요구되는 사업주 및 최고 관리자 포털을 위해서는 전략적인 선택이 필요합니다.

- **Blazor Server:** UI 상호작용이 SignalR 연결을 통해 처리됩니다. 이는 애플리케이션 로직을 서버에 유지하여 씬 클라이언트(thin client)를 구현하고 보안을 강화합니다. 신뢰할 수 있는 네트워크에서 사용되는 내부 도구나 포털에 이상적입니다.16
    
- **Blazor WebAssembly (WASM):** 앱이 전적으로 브라우저에서 실행됩니다. 초기 로드 크기는 클 수 있지만, 이후 상호작용은 즉각적입니다. 오프라인 기능이 필요하거나 공개용 사이트에 더 적합합니다.16
    
- **Auto 렌더 모드:** 서버 모드로 시작하여 후속 방문 시 WASM으로 전환됩니다.
    

#### 권장 사항: Blazor Server (`InteractiveServer`)

사업주 및 최고 관리자 포털에는 **Blazor Server (`InteractiveServer`)** 렌더 모드를 권장합니다. 주요 이유는 다음과 같습니다:

1. **보안:** 비즈니스 로직이나 민감한 데이터가 클라이언트의 브라우저로 다운로드되지 않습니다.
    
2. **성능:** 이러한 백오피스 도구에는 빠른 초기 로드 시간이 중요합니다.
    
3. **단순성:** 개발 모델이 더 간단하며, 서버 환경에서 Supabase 클라이언트를 통한 직접적인 데이터베이스 접근이 더 안전합니다.
    

`-I Server` 플래그를 사용하여 `maui-blazor-web` 템플릿으로 프로젝트를 초기 설정하는 것은 이 권장 사항과 완벽하게 일치합니다.5

### 2.3. 반응형 및 현대적인 UI 설계

#### 2.3.1. UI 컴포넌트 라이브러리 분석

UI 컴포넌트 라이브러리 선택은 개발자 생산성과 사용자 경험에 큰 영향을 미치는 중요한 결정입니다. Blazor 생태계의 주요 오픈소스 경쟁자는 MudBlazor와 Radzen입니다.16

- **MudBlazor:** 미학, 사용 편의성, 그리고 최소한의 JavaScript를 사용하는 "C#-first" 철학에 중점을 둔 Material Design 기반 프레임워크입니다.19 현대적이고 깔끔한 애플리케이션을 만드는 데 뛰어나며 강력한 커뮤니티를 보유하고 있습니다.20 사용자들은 "기본 상태로도 더 보기 좋다"고 평가합니다.21 또한
    
    `MudGrid`, `MudItem`과 같은 완전한 반응형 레이아웃 시스템과 CSS 유틸리티를 제공하여 Bootstrap과 같은 외부 CSS 프레임워크의 필요성을 줄여줍니다.22
    
- **Radzen Blazor Components:** 강력하고 기능이 풍부한 컨트롤, 특히 DataGrid, Scheduler, 차트 덕분에 "엔터프라이즈" 또는 "데이터 집약적인" 애플리케이션에 자주 선호됩니다.17
    
    `RadzenRow`, `RadzenColumn`과 같은 견고한 레이아웃 컴포넌트와 반응형 중단점(breakpoint)에 대한 상세한 제어를 제공합니다.25
    

라이브러리 선택은 미학과 엔터프라이즈급 데이터 컨트롤 간의 트레이드오프 관계에 있습니다. 커뮤니티의 인식과 라이브러리의 초점에서 명확한 차이가 드러납니다. MudBlazor는 개발자 경험과 시각적으로 매력적인 UI에 최적화되어 있고, Radzen은 복잡하고 데이터 중심적인 LOB(Line-of-Business) 애플리케이션 기능에 최적화되어 있습니다.

본 프로젝트는 최종 사용자를 위한 소비자 대면 앱과 사업주/관리자를 위한 데이터 집약적 포털이라는 두 가지 뚜렷한 UI 프로필을 가지고 있습니다. 관리자/사업주 포털은 정렬, 필터링, 가상화와 같은 고급 기능을 갖춘 데이터 그리드에 크게 의존할 것이며, 사용자 피드백은 이 특정 영역에서 Radzen의 우수성을 강력하게 나타냅니다.21 반면, 최종 사용자 앱은 MudBlazor의 핵심 강점인 세련되고 모바일 우선적인 Material Design 느낌을 우선시할 수 있습니다.20

두 개의 다른 라이브러리를 사용하는 것은 기술적으로 가능하지만 복잡성과 인지적 부담을 가중시키므로, 일관된 단일 라이브러리가 바람직합니다. Radzen의 경우 모바일에서 버그가 보고된 바 있어 28 대상 디바이스에서의 철저한 테스트가 필요합니다.

결론적으로, 본 보고서는 사업주 및 관리자 포털에서 고급 데이터 컴포넌트의 중요성을 고려하여 **Radzen**을 기본 UI 라이브러리로 권장합니다. 개발팀은 소비자 대면 앱에서 원하는 미학을 달성하기 위해 MudBlazor에 비해 더 많은 커스텀 스타일링이 필요할 수 있다는 점을 인지해야 합니다.21 이 결정은 기본 제공되는 미학보다 기능적 요구사항을 우선시합니다.

#### 2.3.2. Radzen을 이용한 모바일-우선 레이아웃 구현

레이아웃은 12열 반응형 그리드 기반의 `RadzenRow` 및 `RadzenColumn` 컴포넌트를 사용하여 구축될 것입니다.25 Radzen은 xs, sm, md, lg, xl, xxl과 같은 명확한 중단점(breakpoint) 세트를 제공하며, 이를 통해 다양한 화면 크기에서 컴포넌트 속성과 CSS 클래스를 제어할 수 있습니다.26

다음은 일반적인 패턴을 보여주는 구체적인 Razor 코드 예제입니다.

C#

```
<RadzenRow>
    <RadzenColumn Size="12" SizeMD="6" SizeLG="4">
        </RadzenColumn>
    <RadzenColumn Size="12" SizeMD="6" SizeLG="4">
        </RadzenColumn>
    <RadzenColumn Size="12" SizeMD="12" SizeLG="4">
        </RadzenColumn>
</RadzenRow>
```

이 예제는 25과 26의 이론적 개념을 개발팀이 즉시 활용할 수 있는 실행 가능한 패턴으로 변환합니다.

### 2.4. Fluxor를 이용한 고급 상태 관리

#### 필요성

다중 사용자 역할, 실시간 업데이트, 다단계 양식 등 복잡성을 가진 애플리케이션에서 상태 관리는 중요한 과제입니다. 의존성 주입 서비스나 계단식 매개변수와 같은 간단한 접근 방식은 규모가 커지면 관리하기 어려워집니다.29

#### 해결책: Flux 패턴

예측 가능하고 단방향 데이터 흐름을 강제하는 Flux 아키텍처를 채택할 것입니다. Fluxor는 Blazor를 위한 이 패턴의 성숙하고 인기 있는 구현체입니다.30

#### Fluxor의 핵심 개념

- **Store:** 애플리케이션 상태의 중앙화된 단일 진실 공급원(single source of truth).
    
- **State:** 특정 시점의 상태를 나타내는 불변 객체 (C# 레코드 권장).31
    
- **Actions:** 상태 변경을 설명하는 간단한 명령 객체 (예: `IncrementCounterAction`). Store로 전달(dispatch)됩니다.32
    
- **Reducers:** 현재 상태와 액션을 받아 _새로운_ 상태를 생성하는 순수 함수. 상태를 변경할 수 있는 유일한 주체입니다.31
    
- **Effects:** API 호출(예: Supabase 클라이언트 호출)과 같은 부수 효과(side effect)를 처리합니다. 액션에 의해 트리거되며, 완료 시 새로운 액션을 전달할 수 있습니다 (예: `DataFetchedAction`).31
    

#### 구현 단계

1. `Fluxor.Blazor.Web` NuGet 패키지를 설치합니다.
    
2. `Program.cs`에 Fluxor를 등록합니다: `builder.Services.AddFluxor(o => o.ScanAssemblies(typeof(Program).Assembly));`.30
    
3. 루트 컴포넌트(`Routes.razor` 또는 `App.razor`)에서 Store를 초기화합니다: `<Fluxor.Blazor.Web.StoreInitializer />`.32
    
4. ``클래스, `Action` 레코드,`` 함수, `[EffectMethod]` 클래스를 생성합니다.
    
5. 컴포넌트에 `IDispatcher`와 `IState<T>`를 주입하여 액션을 전달하고 상태 변경을 구독합니다.
    
6. 컴포넌트는 `FluxorComponent`를 상속받아야 구독하는 상태가 변경될 때 자동으로 다시 렌더링됩니다 (이는 33에서 지적된 흔한 함정입니다).
    

#### Blazor Hybrid 환경에서의 Fluxor

Fluxor에 대한 기존 문서와 튜토리얼은 30 Blazor Web(Server 또는 WASM)에만 초점을 맞추고 있으며,.NET MAUI Blazor Hybrid 애플리케이션 내에서의 사용에 대한 구체적인 가이드는 없습니다.

Fluxor의 핵심 로직(액션, 리듀서, 이펙트)은 순수 C#이며 플랫폼에 구애받지 않으므로 MAUI 앱의.NET 런타임 내에서 올바르게 작동할 것입니다. `StoreInitializer`나 `FluxorComponent`와 같은 통합 지점은 하이브리드 모델에서도 일관된 Blazor의 컴포넌트 생명주기에 맞춰 설계되었습니다.

그러나 네이티브 모바일 앱의 생명주기(예: 앱 백그라운드 전환, 일시 중지, 종료)와 Fluxor 스토어 상태가 상호작용하는 방식에서 예기치 않은 문제가 발생할 수 있습니다. 예를 들어, 앱이 백그라운드로 전환될 때 상태를 디바이스 저장소에 영속화해야 하는지 여부입니다. 29에서 논의된

`localStorage`나 `sessionStorage`와 같은 표준 브라우저 저장소 메커니즘은 직접 적용할 수 없으며, MAUI의 `Preferences`나 로컬 SQLite 데이터베이스와 같은 네이티브 저장소 API가 그 대안이 될 것입니다.

결론적으로, Fluxor가 올바른 아키텍처 선택임은 분명하지만, Blazor Hybrid에 적용하는 것은 팀이 새로운 영역을 개척하는 것과 같습니다. 본 보고서는 네이티브 앱 생명주기에 맞춰 상태를 영속화하고 재수화(rehydration)하는 전략을 개발할 것을 핵심 권장 사항으로 제시합니다. 이는 기존 Fluxor 문서에서 다루지 않는 중요한 리스크이며, 이에 대한 계획 수립이 필수적입니다.

---

## 제 3부: Supabase 백엔드의 성능 및 보안 극대화

이 파트는 백엔드 구현의 기술적 핵심으로, Supabase의 가장 강력한 기능들을 활용하여 안전하고 확장 가능하며 유지보수 가능한 시스템을 구축하는 방법을 상세히 설명합니다.

### 3.1. 데이터 모델링 및 인증 통합

#### 스키마 설계

Supabase 대시보드에서 PostgreSQL 스키마를 설계하는 모범 사례를 따릅니다. 여기에는 테이블(`users`, `businesses`, `orders` 등) 정의, 관계(외래 키) 설정, 그리고 중요한 테이블에 대한 실시간 기능 활성화가 포함됩니다.8

#### Supabase C# 클라이언트

`supabase-csharp` 커뮤니티 라이브러리는.NET 코드에서 Supabase와 상호작용하는 주요 인터페이스가 될 것입니다.11 이 라이브러리는 인증, PostgREST, 스토리지, 실시간 기능에 대한 강력한 형식의 접근을 제공합니다.11 이 라이브러리는 커뮤니티에 의해 유지보수되므로, 업데이트 및 주요 변경 사항을 주시해야 합니다.11

#### 인증 흐름

1. 사용자가 Blazor 컴포넌트를 통해 회원가입 또는 로그인합니다.
    
2. 컴포넌트는 공유 서비스 라이브러리의 `AuthService`를 호출합니다.
    
3. `AuthService`는 `supabase-csharp` 클라이언트를 사용하여 Supabase Auth를 호출합니다 (예: `_supabase.Auth.SignIn(email, password)`).9
    
4. 성공 시, Supabase는 JWT를 반환합니다.
    
5. 이 JWT는 안전하게 저장되어야 합니다. Blazor Web App(Server)의 경우, 메모리나 보안 쿠키에 관리될 수 있습니다. MAUI Hybrid 앱의 경우, 플랫폼의 보안 저장소(`Microsoft.Maui.Storage.SecureStorage`)에 저장해야 합니다. 웹 앱에서 언급된 `localStorage` 접근 방식은 29 JWT에 대해 충분히 안전하지 않으며 MAUI에서는 직접 사용할 수 없습니다.
    
6. 커스텀 `SupabaseAuthenticationStateProvider`가 구현될 것입니다. 이 제공자는 저장된 JWT를 읽고 유효성을 검사한 후, 사용자를 위한 `ClaimsPrincipal`을 생성하여 `<CascadingAuthenticationState>`를 통해 앱 전체에서 인증 상태를 사용할 수 있게 합니다.9
    

### 3.2. 행 수준 보안(RLS) 심층 분석

#### 핵심 원칙: 보안 모델의 근간

RLS는 선택적 기능이 아니라, **전체 보안 모델의 기반**입니다. 사용자별 또는 역할별 데이터를 포함하는 모든 테이블은 _반드시_ RLS를 활성화해야 합니다.6

#### 작동 방식

RLS 정책은 본질적으로 Postgres가 모든 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 쿼리에 자동으로 적용하는 `WHERE` 절입니다. 이 정책들은 세션의 JWT를 사용하여 결정을 내리며, 일반적으로 인증된 사용자의 ID를 반환하는 `auth.uid()` 함수를 통해 이루어집니다.10

#### 구체적인 RLS 정책 예제

이 섹션에서는 세 가지 필수 역할을 구현하기 위한 실제 운영 환경 수준의 SQL 코드를 제공합니다. `auth.users` 테이블에 연결된 `role` 텍스트 열('user', 'owner', 'admin')을 가진 `profiles` 테이블을 가정합니다.

- **테이블 설정:**
    
    SQL
    
    ```
    -- profiles 테이블은 공개 사용자 데이터와 역할을 저장합니다.
    CREATE TABLE public.profiles (
      id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
      role text CHECK (role IN ('user', 'owner', 'admin')),
      PRIMARY KEY (id)
    );
    -- 현재 사용자의 역할을 가져오는 함수
    CREATE OR REPLACE FUNCTION public.get_my_role()
    RETURNS text AS $$
      SELECT role FROM public.profiles WHERE id = auth.uid();
    $$ LANGUAGE sql STABLE;
    ```
    
- **`stores` 테이블에 대한 사업주 정책:**
    
    SQL
    
    ```
    -- stores 테이블에 RLS 활성화
    ALTER TABLE public.stores ENABLE ROW LEVEL SECURITY;
    
    -- 1. 사업주는 자신의 가게만 볼 수 있습니다.
    CREATE POLICY "Owners can view their own stores"
    ON public.stores FOR SELECT
    USING (auth.uid() = owner_id);
    
    -- 2. 사업주는 자신을 위해 새 가게를 등록할 수 있습니다.
    CREATE POLICY "Owners can insert their own stores"
    ON public.stores FOR INSERT
    WITH CHECK (auth.uid() = owner_id);
    
    -- 3. 사업주는 자신의 가게만 수정할 수 있습니다.
    CREATE POLICY "Owners can update their own stores"
    ON public.stores FOR UPDATE
    USING (auth.uid() = owner_id);
    ```
    
- **최고 관리자 정책:**
    
    SQL
    
    ```
    -- 관리자는 모든 가게에 대해 모든 작업을 수행할 수 있습니다.
    CREATE POLICY "Admins have full access"
    ON public.stores FOR ALL
    USING (public.get_my_role() = 'admin');
    ```
    

#### RLS의 힘과 위험

RLS는 매우 강력하지만 디버깅이 복잡할 수 있습니다. 잘못 구성된 정책은 데이터 유출로 이어지거나 사용자가 데이터를 전혀 볼 수 없게 만들 수 있습니다. Supabase SQL 편집기에서 직접 RLS 정책을 작성하고 테스트하는 개발자 경험은 다소 번거로울 수 있습니다.

RLS는 보안 로직을 데이터베이스로 이동시킵니다.10 이 로직은 C# 개발자에게는 애플리케이션 계층 코드보다 덜 익숙할 수 있는 SQL로 작성됩니다. 디버깅은 간접적입니다. 개발자는 앱에서 정책 실행 자체를 보는 것이 아니라 정책의 결과(또는 결과 없음)를 보게 됩니다. RLS 정책 내의 복잡한 조인은 성능에 영향을 미칠 수 있습니다.37

결론적으로, 본 보고서는 RLS에 대한 엄격한 테스트 전략을 권장합니다. 각 역할에 대한 전용 테스트 사용자를 생성하고, 데이터 접근 및 수정을 시도하여 올바른 데이터가 반환되거나 올바른 오류가 발생하는지 확인하는 자동화된 테스트를 작성해야 합니다. 또한 팀은 RLS 하에서 쿼리 성능을 분석하기 위해 Postgres의 `EXPLAIN` 사용법을 배우는 데 시간을 투자해야 합니다.

### 3.3. 비즈니스 로직의 위치: Postgres 함수 vs. 엣지 함수

#### 딜레마

모든 비즈니스 로직이 CRUD 작업에 적합한 것은 아닙니다. 프로젝트는 더 복잡한 로직을 어디에 배치할지 결정해야 합니다. Supabase는 두 가지 강력한 옵션을 제공합니다.6

#### Postgres 함수

- **사용 사례:** 데이터 집약적이고 트랜잭션이 필요한 로직에 이상적입니다. 예: 사용자의 총 주문 금액 계산, 단일 트랜잭션으로 새 사용자와 관련 프로필 생성, 여러 테이블을 확인해야 하는 데이터 유효성 검사.6
    
- **장점:** 데이터베이스 내에서 실행되어 최고의 성능을 보장하며, 원자적 트랜잭션의 일부가 될 수 있고, 로직이 데이터와 함께 존재합니다.7
    
- **단점:** PL/pgSQL로 작성되어 익숙하지 않은 개발자에게는 "어색한" 개발 경험을 줄 수 있으며 7, 외부 API와 통합하기가 더 어렵습니다.
    

#### 엣지 함수

- **사용 사례:** 외부 서비스와 관련된 로직에 이상적입니다. 예: Stripe로 결제 처리, 타사 서비스를 통한 환영 이메일 발송, 웹훅 처리, AI API와의 통합.6
    
- **장점:** TypeScript/Deno로 작성되어 현대적인 개발 경험을 제공하며, 다른 서비스에 대한 HTTP 요청을 쉽게 할 수 있습니다.
    
- **단점:** 순수 데이터베이스 작업의 경우 Postgres 함수보다 지연 시간이 깁니다. 관리해야 할 또 다른 서비스가 추가됩니다.
    

#### 표 3.3.1: 비즈니스 로직 배치 결정 매트릭스

이 표는 개발팀이 일관된 아키텍처 결정을 내릴 수 있도록 명확하고 실행 가능한 프레임워크를 제공합니다. 7에서의 논쟁은 이것이 숙련된 개발자들 사이에서도 논쟁의 여지가 있는 지점임을 보여줍니다. 공식적인 결정 매트릭스는 모호성을 제거하고 일관성 없는 임시적인 선택을 방지합니다. 이는 주관적인 논쟁을 특정 로직의 요구사항에 기반한 객관적인 평가로 전환시킵니다.

|**기준**|**Postgres 함수 선호**|**엣지 함수 선호**|**사용 사례 예시**|
|---|---|---|---|
|**데이터 지역성**|높음 (다중 테이블 트랜잭션)|낮음 (오케스트레이션)|**PG:** 주문 생성 및 재고 업데이트|
|**성능**|중요 (밀리초 미만 응답)|허용 (100ms 이상 응답)|**엣지:** Stripe 웹훅 처리|
|**외부 API**|아니요|예|**엣지:** SendGrid를 통한 환영 이메일 발송|
|**로직 복잡성**|복잡한 SQL, 단순한 흐름|단순한 SQL, 복잡한 흐름/로직|**PG:** 복잡한 재무 계산|
|**개발 경험**|팀이 SQL에 강함|팀이 TypeScript/JS에 강함|**엣지:** 맞춤형 사용자 온보딩 흐름|

### 3.4. 실시간 기능 구현

#### 핵심 원칙

Supabase 실시간 기능은 서버가 연결된 클라이언트에 데이터를 푸시하여 생동감 있고 동적인 사용자 경험을 가능하게 합니다.12

#### 메커니즘

실시간 기능은 Postgres의 내장된 논리적 복제 기능을 수신합니다. 실시간 기능이 활성화된 테이블에서 변경(INSERT, UPDATE, DELETE)이 발생하면, Supabase는 해당 변경 사항을 구독 중인 클라이언트에 브로드캐스트합니다.35

#### 구현 예제

일반적인 사용 사례인, 사업주 대시보드에서 새로운 사용자 가입을 실시간으로 보여주는 코드 스니펫을 제공합니다.

1. **실시간 활성화:** Supabase 대시보드에서 `profiles` 테이블의 실시간 기능을 켭니다.13
    
2. **Blazor에서 구독:** 대시보드 컴포넌트의 `OnInitializedAsync` 메서드에서 `supabase-csharp` 클라이언트를 사용하여 변경 사항을 구독합니다.
    
    C#
    
    ```
    // 주입: Supabase.Client _supabase;
    private RealtimeChannel _profilesChannel;
    
    protected override async Task OnInitializedAsync()
    {
        await _supabase.Realtime.ConnectAsync();
        _profilesChannel = _supabase.Realtime.Channel("public", "profiles");
        _profilesChannel.AddPostgresChangeHandler(ListenType.Insert, (sender, change) => {
            var newProfile = change.Model<Profile>();
            // UI 목록에 새 프로필을 추가하고 StateHasChanged() 호출
            // 또는 더 나은 방법으로 Fluxor 액션 전달:
            // Dispatcher.Dispatch(new NewUserSignedUpAction(newProfile));
            InvokeAsync(StateHasChanged);
        });
        await _profilesChannel.Subscribe();
    }
    ```
    

이 예제는 35과 13에서 종합하여 개발팀에게 실용적이고 즉시 사용 가능한 시작점을 제공하며, 깔끔한 상태 업데이트를 위해 Fluxor 패턴과도 통합됩니다.

---

## 제 4부: 통합, 배포 및 운영

이 마지막 기술 파트에서는 네이티브 기능 통합과 모든 애플리케이션 대상에 대한 견고하고 자동화된 배포 파이프라인 구축이라는 중요한 "마지막 마일" 과제를 다룹니다.

### 4.1. 네이티브 디바이스 기능 접근: 푸시 알림 사례 연구

#### 과제

푸시 알림은 플랫폼별 설정과 통합이 필요한 중요한 네이티브 기능입니다.

#### 프로세스

다음은 종단 간 가이드입니다.

1. **백엔드 설정 (Firebase/APNS):** Android용 Firebase 프로젝트를 생성하고 iOS용 Apple 푸시 알림 서비스(APNS)를 구성합니다. 여기에는 `google-services.json` 및 Apple P8 인증서 생성이 포함됩니다.39
    
2. **MAUI 프로젝트 구성:**
    
    - 필요한 NuGet 패키지(예: Android용 `Plugin.Firebase` 또는 크로스 플랫폼 추상화 라이브러리)를 추가합니다.39
        
    - `google-services.json` 파일을 올바른 `GoogleServicesJson` 빌드 액션으로 Android 프로젝트에 추가합니다.39
        
    - `AndroidManifest.xml`(Android 권한 `POST_NOTIFICATIONS` 등) 및 `Info.plist`/`Entitlements.plist`(iOS 기능)를 구성합니다.39
        
3. **추상화 계층:** 공유 서비스 라이브러리에 `INotificationService` 인터페이스를 생성합니다. 조건부 컴파일을 사용하여 `Platforms/Android` 및 `Platforms/iOS` 폴더에 이 서비스의 플랫폼별 버전을 구현합니다.41
    
4. **알림 수신:** 플랫폼별 구현은 OS로부터 알림 페이로드를 수신하고, 공유 Blazor 코드가 구독할 수 있는 크로스 플랫폼 이벤트를 발생시키는 것을 처리합니다.41
    
5. **알림 발송:** 알림 발송은 Firebase Admin SDK 또는 APNS 라이브러리를 사용하여 올바른 디바이스 토큰(앱 로그인 시 사용자 프로필에 저장됨)으로 알림을 보내는 Supabase 엣지 함수에 의해 처리될 가능성이 높습니다.
    

### 4.2. 웹 및 모바일용 CI/CD 파이프라인

#### 핵심 원칙

수동 배포는 오류가 발생하기 쉽고 느립니다. 모든 세 애플리케이션 대상에 대해 GitHub Actions를 사용하여 자동화된 CI/CD 파이프라인을 정의할 것입니다.

#### 4.2.1. 웹 포털을 Azure App Service에 배포

Blazor Server 애플리케이션의 경우, **Azure App Service**가 가장 적합한 호스팅 대상입니다. Azure Static Web Apps는 주로 Blazor WASM과 같은 정적 클라이언트 앱에 최적화되어 있습니다.

- **Azure App Service에 배포 (Blazor Server용):**
    
    1. Azure App Service 인스턴스를 생성합니다.
        
    2. GitHub Actions 워크플로우 파일(`.github/workflows/deploy.yml`)을 생성합니다.
        
    3. 워크플로우는 다음을 수행합니다:
        
        - 코드 체크아웃
            
        - .NET 8 SDK 설정
            
        - `YourApp.Web` 프로젝트에 대해 `dotnet publish` 실행
            
        - `azure/webapps-deploy@v2` 액션을 사용하여 게시된 아티팩트를 App Service에 배포
            
    4. Supabase 비밀 키(URL, Anon Key)는 GitHub Actions 비밀로 저장되고 App Service 구성에서 환경 변수로 애플리케이션에 전달됩니다.
        

#### 4.2.2. 모바일 앱을 앱 스토어에 배포

- **전제 조건:** Apple 개발자 프로그램 계정과 Google Play 개발자 계정이 필수입니다.42 iOS 빌드에는 실제 Mac이 필요합니다.43
    
- **프로세스 (GitHub Actions 사용):**
    
    1. **코드 서명:** 가장 복잡한 부분입니다. Apple 프로비저닝 프로필, 인증서, Google Keystore 파일은 GitHub에 비밀로 안전하게 저장되어야 합니다.
        
    2. **빌드 워크플로우:** GitHub Actions 워크플로우는 `macos-latest` 실행기를 사용합니다.
        
    3. **iOS 단계:**
        
        - 서명 인증서와 프로비저닝 프로필을 설치합니다.
            
        - 명령줄 게시 명령을 실행합니다: `dotnet publish -f:net8.0-ios -c:Release /p:BuildIpa=True` (이 명령은 44과 43에서 파생되었으며, 서명된
            
            `.ipa` 파일을 빌드합니다).
            
        - 커뮤니티 액션을 사용하여 Transporter 도구를 통해 `.ipa`를 App Store Connect에 업로드합니다.
            
    4. **Android 단계:**
        
        - 비밀에서 서명 키스토어를 설치합니다.
            
        - 명령줄 게시 명령을 실행하여 서명된 `.aab`(Android App Bundle)를 빌드합니다: `dotnet publish -f:net8.0-android -c:Release`.
            
        - 커뮤니티 액션을 사용하여 `.aab`를 Google Play Console에 업로드합니다.
            

#### 배포는 MAUI 개발의 가장 복잡한 부분

배포 관련 자료들은 42 인증서, 식별자, 프로비저닝 프로필과 관련된 복잡성을 지속적으로 강조하며, 특히 iOS의 경우 더욱 그렇습니다. C#에서의 핵심 애플리케이션 개발은 플랫폼별 배포 생태계를 탐색하는 것에 비하면 상대적으로 "쉬운" 부분입니다.

Apple의 프로세스는 특히 악명 높으며, Apple ID, 유료 개발자 계정, 빌드를 위한 Mac, 그리고 수많은 자산(인증서, 앱 ID, 프로비저닝 프로필) 생성을 요구합니다.43 이러한 복잡성은.NET MAUI 프레임워크 자체와는 무관하지만, 프로젝트 생명주기의 피할 수 없는 부분입니다.

결론적으로, 본 보고서는 배포를 주요 프로젝트 단계로 취급하고 상당한 부분을 할애해야 합니다. 프로젝트 리더에게 이것이 전담 시간과 잠재적으로 전문 지식이 필요할 것임을 경고해야 합니다. CI/CD 파이프라인에서 자동화를 시도하기 전에 먼저 수동 배포를 수행하여 모든 단계를 이해하는 것이 권장됩니다.

#### 표 4.2.1: 플랫폼 배포 전략 요약

여러 배포 가능한 아티팩트가 다른 플랫폼을 대상으로 하는 프로젝트에서는 혼란이 발생하기 쉽습니다. 이 표는 배포의 "무엇을, 어디에, 어떻게"를 중앙에서 관리하여 DevOps/운영팀 및 프로젝트 관리에 필수적인 참조 자료 역할을 합니다.

|**애플리케이션**|**대상 역할**|**기술**|**배포 대상**|**CI/CD 도구**|**핵심 아티팩트**|
|---|---|---|---|---|---|
|**네이티브 앱**|최종 사용자|.NET MAUI Blazor Hybrid|Apple App Store|GitHub Actions|`.ipa`|
|**네이티브 앱**|최종 사용자|.NET MAUI Blazor Hybrid|Google Play Store|GitHub Actions|`.aab`|
|**웹 포털**|사업주, 관리자|Blazor Web App (Server)|Azure App Service|GitHub Actions|게시된 웹 앱|

---

## 제 5부: 전략적 종합 및 최종 권장 사항

이 마지막 파트는 기술 가이드에서 전략 문서로 보고서의 수준을 높여, 주요 결정을 요약하고 미래 지향적인 조언을 제공합니다.

### 5.1. 주요 아키텍처 결정 요약

- 간결하고 상위 수준의 주요 권장 사항 요약:
    
    1. **통합 아키텍처:** 최대 코드 재사용을 위해 `maui-blazor-web` 템플릿을 채택합니다.5
        
    2. **BaaS-First 백엔드:** Supabase를 극대화하고, RLS를 보안 모델의 핵심으로 사용하며, 맞춤형 백엔드 코드를 최소화합니다.6
        
    3. **UI 라이브러리:** 강력한 데이터 컴포넌트를 위해 Radzen으로 표준화하고, 맞춤형 스타일링의 필요성을 수용합니다.21
        
    4. **상태 관리:** 예측 가능하고 확장 가능한 상태 모델을 보장하기 위해 프로젝트 초기부터 Fluxor를 구현합니다.30
        
    5. **배포:** 앱 스토어 배포를 전담 인력이 필요한 주요하고 복잡한 작업 흐름으로 취급합니다.43
        

### 5.2. 식별된 리스크 및 완화 계획

- **리스크 1: 커뮤니티 라이브러리 의존성:** `supabase-csharp` 클라이언트는 Supabase가 공식적으로 지원하는 것이 아니라 커뮤니티에서 지원합니다.11
    
    - **완화 계획:** 클라이언트 주위에 추상화 계층(래퍼)을 만듭니다. 이는 라이브러리의 주요 변경 사항으로부터 애플리케이션을 격리하고, 필요한 경우 더 쉽게 교체할 수 있도록 합니다. 오픈소스 프로젝트에 대한 잠재적인 기여나 버그 수정 시간을 프로젝트 계획에 할당합니다.
        
- **리스크 2: Blazor Hybrid 상태 관리의 미묘함:** 네이티브 앱 생명주기 컨텍스트에서 Fluxor에 대한 공식적인 지침이 부족합니다.31
    
    - **완화 계획:** 개발 주기 초기에 상태 영속성/재수화 시나리오를 프로토타이핑하고 테스트합니다. 특히, OS에 의해 앱이 백그라운드, 일시 중지, 종료될 때 앱 상태가 어떻게 동작하는지 테스트합니다.
        
- **리스크 3: 배포 복잡성:** 앱 스토어에 서명하고 배포하는 과정은 본질적으로 복잡하고 플랫폼에 따라 다릅니다.43
    
    - **완화 계획:** "배포 전문가"가 될 전담 팀원을 지정합니다. 자동화 전에 먼저 수동 배포를 수행합니다. 모든 인증서 및 프로필 생성 단계를 훌륭하게 문서화합니다.
        

### 5.3. 향후 발전 및 확장성을 위한 로드맵

- **Supabase 확장:** 더 큰 전용 인스턴스 및 읽기 전용 복제본으로 이동하는 것을 포함하여 Supabase의 확장 경로를 논의합니다.
    
- **비즈니스 로직의 진화:** 애플리케이션이 성장함에 따라, 특정 기능에 대해 BaaS 모델이 진정으로 한계에 도달하면 Postgres 함수에서 전용 마이크로서비스(예: 컨테이너에서 실행되는.NET API)로 더 복잡한 로직을 마이그레이션할 수 있습니다. 초기 아키텍처는 이러한 미래의 진화를 배제하지 않습니다.
    
- **고급 기능:** 현재 스택이 향후 AI 기반 검색을 위한 벡터 임베딩(`pg_vector`) 46이나 Presence를 사용한 실시간 협업 35과 같은 더 고급 Supabase 기능을 어떻게 통합할 수 있는지 간략하게 다룹니다.