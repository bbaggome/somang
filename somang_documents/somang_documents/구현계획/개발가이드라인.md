## T-Bridge 개발 가이드라인

본 문서는 T-Bridge 프로젝트의 코드 품질, 일관성, 유지보수성을 확보하기 위해 모든 개발자가 준수해야 할 핵심 개발 원칙과 표준 구현 방안을 정의합니다.

### 1. 기본 개발 원칙

| 원칙 | 내용 |
| :--- | :--- |
| **언어 및 프레임워크** | - 모든 신규 개발은 **.NET 8** 및 **C# 12**를 주력으로 사용합니다.<br>- 특정 패키지와의 호환성 등 불가피한 경우에만 팀 합의 하에 다른 .NET 버전을 고려할 수 있습니다. |
| **설계 철학** | - **SOLID 원칙**을 준수하여 유연하고 확장 가능한 코드를 작성합니다.<br>- 각 원칙을 맹목적으로 따르기보다, 프로젝트의 복잡성과 요구사항에 맞춰 합리적으로 적용합니다. |
| **아키텍처 패턴** | - **의존성 주입(DI)** 패턴을 적극적으로 활용합니다. 모든 서비스와 종속성은 인터페이스를 통해 추상화하고, DI 컨테이너를 통해 주입받습니다.<br>- UI와 비즈니스 로직을 분리하기 위해 **MVVM 패턴**을 적용하며, **CommunityToolkit.MVVM** 라이브러리를 활용합니다. |

---

### 2. SOLID 원칙 적용 가이드

- **(S) 단일 책임 원칙 (Single Responsibility Principle)**
  - **가이드**: 하나의 클래스, 메서드는 하나의 책임만 가져야 합니다.
  - **적용 예시**: `QuoteService`는 견적 생성, 조회, 수정 등 '견적'과 관련된 책임만 가집니다. 사용자 인증이나 판매점 정보 수정과 같은 로직은 각각 `AuthService`, `StoreService`에서 처리해야 합니다.

- **(O) 개방-폐쇄 원칙 (Open/Closed Principle)**
  - **가이드**: 기존 코드를 변경하지 않고(Closed) 기능을 확장(Open)할 수 있어야 합니다.
  - **적용 예시**: 결제 로직 구현 시 `IPaymentGateway` 인터페이스를 정의합니다. 향후 새로운 결제 수단(예: 토스페이)이 추가되더라도, 기존 `PaymentService`의 변경 없이 `TossPaymentGateway` 클래스를 새로 구현하여 기능을 확장합니다.

- **(L) 리스코프 치환 원칙 (Liskov Substitution Principle)**
  - **가이드**: 자식 클래스는 부모 클래스의 역할을 완벽하게 대체할 수 있어야 합니다.
  - **적용 예시**: `BaseNotificationService`를 상속받는 `SmsNotificationService`와 `EmailNotificationService`는 모두 `SendNotification()`이라는 동일한 시그니처의 메서드를 일관되게 구현해야 합니다.

- **(I) 인터페이스 분리 원칙 (Interface Segregation Principle)**
  - **가이드**: 클라이언트가 사용하지 않는 기능에 의존해서는 안 되며, 인터페이스를 역할에 맞게 작게 분리해야 합니다.
  - **적용 예시**: 거대한 `IDataService` 대신, `IQuoteReaderService`(읽기 전용), `IQuoteWriterService`(쓰기 전용) 등으로 인터페이스를 분리하여, 각 클라이언트가 필요한 최소한의 기능만 노출합니다.

- **(D) 의존관계 역전 원칙 (Dependency Inversion Principle)**
  - **가이드**: 상위 모듈은 하위 모듈의 구체적인 구현에 의존해서는 안 되며, 반드시 추상화(인터페이스)에 의존해야 합니다.
  - **적용 예시**: Blazor 페이지(`MyQuotes.razor`)는 구체적인 `QuoteService` 클래스에 직접 의존하는 것이 아니라, `IQuoteService` 인터페이스에 의존합니다. 실제 구현체는 DI 컨테이너(`MauiProgram.cs` 등)가 주입해줍니다.

### 3. 패턴 구현 가이드

#### 3.1. DI 및 서비스 계층 구현

- 모든 비즈니스 로직은 `TBridge.Shared.Services` 프로젝트 내의 **서비스 클래스**에 구현하는 것을 원칙으로 합니다.
- 모든 서비스 클래스는 반드시 **인터페이스**를 가져야 합니다. (예: `IQuoteService` - `QuoteService`)
- 서비스의 생명주기(Singleton, Scoped, Transient)는 역할에 맞게 `MauiProgram.cs`의 `builder.Services`에 등록합니다.

```csharp
// In MauiProgram.cs

// 1. Registering the service with its interface
builder.Services.AddScoped<IQuoteService, QuoteService>();

// ...

// In a Blazor component or ViewModel
public class MyQuotesViewModel
{
    private readonly IQuoteService _quoteService;

    // 2. Injecting the service via constructor
    public MyQuotesViewModel(IQuoteService quoteService)
    {
        _quoteService = quoteService;
    }
}
```

#### 3.2. MVVM 패턴 및 상태 관리 구현

T-Bridge는 UI 로직 분리를 위해 **MVVM 패턴**을, 전역 상태 관리를 위해 **Fluxor**를 사용하는 하이브리드 접근 방식을 채택합니다.

- **ViewModel의 역할 (using `CommunityToolkit.MVVM`)**:
  - `ObservableObject`를 상속하여 속성 변경을 UI에 알립니다 (`INotifyPropertyChanged`).
  - UI에서 실행될 명령은 `[RelayCommand]` 어트리뷰트를 사용하여 메서드를 정의합니다.
- **Fluxor의 역할**:
  - 애플리케이션의 상태(State)는 Fluxor Store에 중앙 집중식으로 관리되며, **단일 진실 공급원(Single Source of Truth)** 역할을 합니다.
  - 상태 변경은 오직 `Action`을 `Dispatcher`로 보내고, `Reducer`가 이를 처리하는 단방향 데이터 흐름을 따릅니다.
- **구현 방식**: ViewModel이 Fluxor의 상태를 구독하고, UI에 필요한 데이터로 가공하여 노출합니다. ViewModel의 명령(Command)은 Fluxor의 Action을 Dispatch하는 역할을 합니다.

```csharp
// Example: QuoteListViewModel.cs

// Use CommunityToolkit.Mvvm for MVVM features
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;

// Use Fluxor for state management
using Fluxor;

// The ViewModel acts as a bridge between the View and the global state
public partial class QuoteListViewModel : ObservableObject
{
    private readonly IState<QuoteState> _quoteState;
    private readonly IDispatcher _dispatcher;

    // ObservableProperty generates the necessary boilerplate for INotifyPropertyChanged
    [ObservableProperty]
    private bool _isLoading;

    [ObservableProperty]
    private IReadOnlyList<Quote> _quotes;

    public QuoteListViewModel(IState<QuoteState> quoteState, IDispatcher dispatcher)
    { 
        _quoteState = quoteState;
        _dispatcher = dispatcher;

        // Subscribe to state changes
        _quoteState.StateChanged += OnStateChanged;

        // Initialize properties from current state
        OnStateChanged(null, null); 
    }

    private void OnStateChanged(object sender, EventArgs e)
    {
        // Update ViewModel properties based on the global state
        IsLoading = _quoteState.Value.IsLoading;
        Quotes = _quoteState.Value.Quotes;
    }

    // RelayCommand creates an ICommand that can be bound to from the UI
    [RelayCommand]
    private void LoadQuotes()
    {
        // Commands dispatch actions, they don't contain business logic themselves
        _dispatcher.Dispatch(new FetchQuotesAction());
    }
}
```