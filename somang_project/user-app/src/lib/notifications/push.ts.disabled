// 1. user-app/src/lib/notifications/push.ts
// ì›¹ Push ì•Œë¦¼ ê´€ë¦¬ ìœ í‹¸ë¦¬í‹°

interface PushSubscriptionData {
  endpoint: string;
  keys: {
    p256dh: string;
    auth: string;
  };
}

/**
 * Service Worker ì°¨ë‹¨ ì—¬ë¶€ í™•ì¸
 */
export async function checkServiceWorkerBlocked(): Promise<boolean> {
  if (typeof window === 'undefined') return false;
  
  // navigator.serviceWorkerê°€ ì¡´ì¬í•˜ì§€ë§Œ ì‹¤ì œë¡œëŠ” ì°¨ë‹¨ëœ ê²½ìš°
  if ('serviceWorker' in navigator) {
    try {
      // getRegistration() í˜¸ì¶œ ì‹œ ì˜ˆì™¸ê°€ ë°œìƒí•˜ë©´ ì°¨ë‹¨ëœ ê²ƒ
      await navigator.serviceWorker.getRegistration();
      return false;
    } catch (error) {
      console.log('Service Workerê°€ ë¸Œë¼ìš°ì €ì—ì„œ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤:', error);
      return true;
    }
  }
  
  return true; // serviceWorkerê°€ ì—†ìœ¼ë©´ ì°¨ë‹¨ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
}

/**
 * ë¸Œë¼ìš°ì € Push ì•Œë¦¼ ì§€ì› ì—¬ë¶€ í™•ì¸
 */
export function isPushSupported(): boolean {
  if (typeof window === 'undefined') {
    console.log('ì„œë²„ ì‚¬ì´ë“œ í™˜ê²½ì—ì„œëŠ” push ì•Œë¦¼ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    return false;
  }

  const hasServiceWorker = 'serviceWorker' in navigator;
  const hasPushManager = 'PushManager' in window;
  const hasNotification = 'Notification' in window;
  
  // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ë” ê´€ëŒ€í•œ ë³´ì•ˆ ì»¨í…ìŠ¤íŠ¸ ì²´í¬
  const isDevelopment = process.env.NODE_ENV === 'development';
  const isLocalhost = location.hostname === 'localhost' || 
                     location.hostname === '127.0.0.1' ||
                     location.hostname.endsWith('.local');
  const isHttps = location.protocol === 'https:';
  
  // ê°œë°œ í™˜ê²½ì˜ localhostë¼ë©´ HTTPSê°€ ì•„ë‹ˆì–´ë„ í—ˆìš©
  const isSecureContext = window.isSecureContext || 
                         isHttps || 
                         (isDevelopment && isLocalhost);

  console.log('Push ì§€ì› ìƒíƒœ í™•ì¸:', {
    hasServiceWorker,
    hasPushManager,
    hasNotification,
    isSecureContext,
    isDevelopment,
    isLocalhost,
    isHttps,
    protocol: location.protocol,
    hostname: location.hostname,
    userAgent: navigator.userAgent.substring(0, 100) + '...'
  });

  // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ê¸°ë³¸ì ì¸ APIë§Œ ì²´í¬í•˜ê³  Service Worker ë¬¸ì œëŠ” ì‹¤ì œ ë“±ë¡ ì‹œì— ì²˜ë¦¬
  if (isDevelopment && isLocalhost) {
    console.log('ğŸš€ ê°œë°œ í™˜ê²½ ê°ì§€: ê¸°ë³¸ API ì§€ì› ì—¬ë¶€ë§Œ ì²´í¬');
    
    const criticalIssues = [];
    
    if (!hasPushManager) {
      criticalIssues.push('PushManagerê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }

    if (!hasNotification) {
      criticalIssues.push('Notification APIê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }

    if (criticalIssues.length > 0) {
      console.warn('âŒ í•„ìˆ˜ API ì§€ì› ë¶ˆê°€:', criticalIssues);
      return false;
    }

    // Service WorkerëŠ” ì‹¤ì œ ë“±ë¡í•  ë•Œ ì²´í¬
    if (!hasServiceWorker) {
      console.warn('âš ï¸ Service Worker ì§€ì›ì´ ê°ì§€ë˜ì§€ ì•Šì§€ë§Œ ê°œë°œ í™˜ê²½ì—ì„œëŠ” ì‹œë„í•´ë´…ë‹ˆë‹¤.');
    }

    console.log('âœ… ê°œë°œ í™˜ê²½ì—ì„œ Push ì•Œë¦¼ ì‹œë„ ê°€ëŠ¥');
    return true;
  }

  // í”„ë¡œë•ì…˜ í™˜ê²½ì—ì„œëŠ” ì—„ê²©í•˜ê²Œ ì²´í¬
  const issues = [];
  
  if (!hasServiceWorker) {
    issues.push('Service Workerê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
  }

  if (!hasPushManager) {
    issues.push('PushManagerê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
  }

  if (!hasNotification) {
    issues.push('Notification APIê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
  }

  if (!isSecureContext) {
    issues.push('HTTPS í™˜ê²½ì´ ì•„ë‹™ë‹ˆë‹¤. Push ì•Œë¦¼ì€ HTTPSì—ì„œë§Œ ì‘ë™í•©ë‹ˆë‹¤.');
  }

  if (issues.length > 0) {
    console.warn('âŒ Push ì•Œë¦¼ ì§€ì› ë¶ˆê°€:', issues);
    return false;
  }

  console.log('âœ… Push ì•Œë¦¼ì´ ì§€ì›ë©ë‹ˆë‹¤.');
  return true;
}

/**
 * ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
 */
export async function requestNotificationPermission(): Promise<NotificationPermission> {
  if (!isPushSupported()) {
    throw new Error('Push notifications are not supported');
  }

  const permission = await Notification.requestPermission();
  return permission;
}

/**
 * Service Worker ë“±ë¡
 */
export async function registerServiceWorker(): Promise<ServiceWorkerRegistration> {
  console.log('ğŸ”„ Service Worker ë“±ë¡ ì‹œë„ ì‹œì‘...');
  
  // ë¨¼ì € Service Worker ì§€ì› ì—¬ë¶€ í™•ì¸
  if (!('serviceWorker' in navigator)) {
    console.error('âŒ navigator.serviceWorkerê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    console.log('í˜„ì¬ í™˜ê²½ ì •ë³´:', {
      userAgent: navigator.userAgent,
      isSecureContext: window.isSecureContext,
      protocol: location.protocol,
      hostname: location.hostname
    });
    console.log('í•´ê²° ë°©ë²•:');
    console.log('1. HTTPSë¡œ ì ‘ì†: https://localhost:50331');
    console.log('2. Chrome í”Œë˜ê·¸ ì„¤ì •: chrome://flags/#unsafely-treat-insecure-origin-as-secure');
    console.log('3. http://localhost:50331 ì¶”ê°€ í›„ ë¸Œë¼ìš°ì € ì¬ì‹œì‘');
    console.log('4. ë˜ëŠ” ì‹œí¬ë¦¿ ëª¨ë“œì—ì„œ í…ŒìŠ¤íŠ¸');
    throw new Error('Service Worker API not available. HTTPS required or enable insecure origins in Chrome flags.');
  }

  try {
    // ê¸°ì¡´ ë“±ë¡ì´ ìˆëŠ”ì§€ í™•ì¸
    console.log('ğŸ”„ ê¸°ì¡´ Service Worker ë“±ë¡ í™•ì¸ ì¤‘...');
    let existingRegistration;
    
    try {
      existingRegistration = await navigator.serviceWorker.getRegistration();
    } catch (getRegError) {
      console.warn('âš ï¸ getRegistration() ì‹¤íŒ¨:', getRegError);
      console.log('Service Worker APIê°€ ì°¨ë‹¨ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
    }
    
    if (existingRegistration) {
      console.log('âœ… ê¸°ì¡´ Service Worker ë“±ë¡ ë°œê²¬:', existingRegistration.scope);
      console.log('Service Worker ìƒíƒœ:', existingRegistration.active?.state);
      
      try {
        await navigator.serviceWorker.ready;
        console.log('âœ… ê¸°ì¡´ Service Worker ì¤€ë¹„ ì™„ë£Œ');
        return existingRegistration;
      } catch (readyError) {
        console.warn('âš ï¸ Service Worker ready ëŒ€ê¸° ì‹¤íŒ¨:', readyError);
        // ê³„ì† ì§„í–‰í•˜ì—¬ ìƒˆë¡œ ë“±ë¡ ì‹œë„
      }
    }

    console.log('ğŸ”„ ìƒˆ Service Worker ë“±ë¡ ì‹œë„: /sw.js');
    
    // ì—¬ëŸ¬ ì˜µì…˜ìœ¼ë¡œ ë“±ë¡ ì‹œë„
    const registrationOptions = [
      { scope: '/', updateViaCache: 'none' },
      { scope: '/' },
      {} // ê¸°ë³¸ ì˜µì…˜
    ];

    let registration: ServiceWorkerRegistration | null = null;
    let lastError: Error | null = null;

    for (const [index, options] of registrationOptions.entries()) {
      try {
        console.log(`ğŸ”„ ë“±ë¡ ì‹œë„ ${index + 1}/${registrationOptions.length}:`, options);
        registration = await navigator.serviceWorker.register('/sw.js', options);
        console.log('âœ… Service Worker ë“±ë¡ ì„±ê³µ!');
        break;
      } catch (regError) {
        console.warn(`âš ï¸ ë“±ë¡ ì‹œë„ ${index + 1} ì‹¤íŒ¨:`, regError);
        lastError = regError as Error;
        continue;
      }
    }

    if (!registration) {
      console.error('âŒ ëª¨ë“  ë“±ë¡ ì‹œë„ ì‹¤íŒ¨');
      throw lastError || new Error('Service Worker registration failed');
    }
    
    console.log('âœ… Service Worker ë“±ë¡ ì„±ê³µ:', {
      scope: registration.scope,
      installing: !!registration.installing,
      waiting: !!registration.waiting,
      active: !!registration.active
    });
    
    console.log('ğŸ”„ Service Worker ì¤€ë¹„ ëŒ€ê¸° ì¤‘...');
    try {
      await navigator.serviceWorker.ready;
      console.log('âœ… Service Worker ì¤€ë¹„ ì™„ë£Œ');
    } catch (readyError) {
      console.warn('âš ï¸ Service Worker ready ëŒ€ê¸° ì‹¤íŒ¨, í•˜ì§€ë§Œ ë“±ë¡ì€ ì„±ê³µ:', readyError);
    }
    
    return registration;
    
  } catch (error) {
    console.error('âŒ Service Worker ë“±ë¡ ì™„ì „ ì‹¤íŒ¨:', error);
    
    if (error instanceof Error) {
      if (error.name === 'SecurityError') {
        console.error('   â†’ ë³´ì•ˆ ì˜¤ë¥˜: ë¸Œë¼ìš°ì €ì—ì„œ Service Workerë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤.');
        console.log('   í•´ê²°ì±…: chrome://settings/privacy â†’ ì‚¬ì´íŠ¸ ì„¤ì • â†’ JavaScript í—ˆìš©');
      } else if (error.name === 'TypeError') {
        console.error('   â†’ íƒ€ì… ì˜¤ë¥˜: Service Worker íŒŒì¼ì— ë¬¸ì œê°€ ìˆê±°ë‚˜ ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        console.log('   /sw.js íŒŒì¼ì´ ì¡´ì¬í•˜ê³  ì ‘ê·¼ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ì„¸ìš”.');
      } else if (error.message.includes('not available')) {
        console.error('   â†’ API ì°¨ë‹¨: ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ Service Workerê°€ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
      }
    }
    
    throw error;
  }
}

/**
 * Push êµ¬ë… ìƒì„±
 */
export async function subscribeToPush(): Promise<PushSubscriptionData | null> {
  try {
    console.log('ğŸ”„ Push êµ¬ë… ì‹œì‘...');
    
    if (!isPushSupported()) {
      console.error('âŒ Push ì•Œë¦¼ì´ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
      return null;
    }

    if (Notification.permission !== 'granted') {
      console.error('âŒ ì•Œë¦¼ ê¶Œí•œì´ í—ˆìš©ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤:', Notification.permission);
      return null;
    }

    console.log('ğŸ”„ Service Worker ë“±ë¡ ì¤‘...');
    const registration = await registerServiceWorker();
    console.log('âœ… Service Worker ë“±ë¡ ì™„ë£Œ');
    
    // VAPID ê³µê°œ í‚¤ (í™˜ê²½ ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨)
    const vapidPublicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY;
    if (!vapidPublicKey) {
      console.error('âŒ VAPID ê³µê°œ í‚¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í™˜ê²½ ë³€ìˆ˜ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
      return null;
    }
    console.log('âœ… VAPID ê³µê°œ í‚¤ í™•ì¸ë¨');

    console.log('ğŸ”„ Push Manager êµ¬ë… ìƒì„± ì¤‘...');
    const subscription = await registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),
    });
    console.log('âœ… Push Manager êµ¬ë… ìƒì„± ì™„ë£Œ');

    const subscriptionData = {
      endpoint: subscription.endpoint,
      keys: {
        p256dh: arrayBufferToBase64(subscription.getKey('p256dh')!),
        auth: arrayBufferToBase64(subscription.getKey('auth')!),
      },
    };

    console.log('âœ… Push êµ¬ë… ë°ì´í„° ìƒì„± ì™„ë£Œ:', {
      endpoint: subscriptionData.endpoint.substring(0, 50) + '...',
      hasP256dh: !!subscriptionData.keys.p256dh,
      hasAuth: !!subscriptionData.keys.auth
    });

    return subscriptionData;
  } catch (error) {
    console.error('âŒ Push êµ¬ë… ì‹¤íŒ¨:', error);
    
    if (error instanceof Error) {
      if (error.name === 'NotSupportedError') {
        console.error('   â†’ Push ì•Œë¦¼ì´ ì§€ì›ë˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.');
      } else if (error.name === 'NotAllowedError') {
        console.error('   â†’ ì‚¬ìš©ìê°€ ì•Œë¦¼ ê¶Œí•œì„ ê±°ë¶€í–ˆìŠµë‹ˆë‹¤.');
      } else if (error.name === 'AbortError') {
        console.error('   â†’ Push êµ¬ë…ì´ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
      } else {
        console.error('   â†’ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜:', error.message);
      }
    }
    
    return null;
  }
}

/**
 * Push êµ¬ë… í•´ì œ
 */
export async function unsubscribeFromPush(): Promise<boolean> {
  try {
    console.log('Getting service worker registration...');
    const registration = await navigator.serviceWorker.getRegistration();
    
    if (!registration) {
      console.log('No service worker registration found');
      return true; // ë“±ë¡ì´ ì—†ìœ¼ë©´ ì´ë¯¸ í•´ì œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
    }

    console.log('Getting push subscription...');
    const subscription = await registration.pushManager.getSubscription();
    
    if (!subscription) {
      console.log('No push subscription found');
      return true; // êµ¬ë…ì´ ì—†ìœ¼ë©´ ì´ë¯¸ í•´ì œëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
    }

    console.log('Unsubscribing from push manager...');
    const result = await subscription.unsubscribe();
    console.log('Push manager unsubscribe result:', result);
    
    return result;
  } catch (error) {
    console.error('Push unsubscription failed:', error);
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ trueë¥¼ ë°˜í™˜í•˜ì—¬ ì„œë²„ ì¸¡ í•´ì œëŠ” ì§„í–‰ë˜ë„ë¡ í•¨
    return true;
  }
}

/**
 * í˜„ì¬ Push êµ¬ë… ìƒíƒœ í™•ì¸
 */
export async function getCurrentSubscription(): Promise<PushSubscriptionData | null> {
  try {
    const registration = await navigator.serviceWorker.getRegistration();
    if (!registration) return null;

    const subscription = await registration.pushManager.getSubscription();
    if (!subscription) return null;

    return {
      endpoint: subscription.endpoint,
      keys: {
        p256dh: arrayBufferToBase64(subscription.getKey('p256dh')!),
        auth: arrayBufferToBase64(subscription.getKey('auth')!),
      },
    };
  } catch (error) {
    console.error('Get subscription failed:', error);
    return null;
  }
}

// Helper functions
function urlBase64ToUint8Array(base64String: string): Uint8Array {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  
  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}